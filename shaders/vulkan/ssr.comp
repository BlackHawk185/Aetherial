#version 450

layout(local_size_x = 8, local_size_y = 8) in;

// G-buffer inputs
layout(set = 0, binding = 0) uniform sampler2D gNormal;
layout(set = 0, binding = 1) uniform sampler2D gPosition;
layout(set = 0, binding = 2) uniform sampler2D gDepth;
layout(set = 0, binding = 3) uniform sampler2D gMetadata;
layout(set = 0, binding = 4) uniform sampler2D hdrBuffer;  // Lit scene (for proper lit reflections)

// Output
layout(set = 0, binding = 5, rgba16f) uniform image2D outputImage;

// Uniforms
layout(push_constant) uniform SSRParams {
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 invViewMatrix;
    mat4 invProjectionMatrix;
} ssr;

// Tuned for close-range voxel reflections
const int MAX_STEPS = 200;
const float STEP_SIZE = 0.5;
const float THICKNESS = 1.0;
const float MAX_DISTANCE = 120.0;

vec3 viewSpaceFromDepth(vec2 uv, float depth) {
    vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewSpace = ssr.invProjectionMatrix * clipSpace;
    return viewSpace.xyz / viewSpace.w;
}

bool rayMarch(vec3 viewRayOrigin, vec3 viewRayDir, out vec2 hitUV, out vec3 hitColor) {
    vec3 currentViewPos = viewRayOrigin;
    float rayLength = 0.0;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        currentViewPos += viewRayDir * STEP_SIZE;
        rayLength += STEP_SIZE;
        
        if (rayLength > MAX_DISTANCE) {
            return false;
        }
        
        // Project current ray position to screen space
        vec4 clipPos = ssr.projectionMatrix * vec4(currentViewPos, 1.0);
        clipPos.xyz /= clipPos.w;
        
        vec2 sampleUV = clipPos.xy * 0.5 + 0.5;
        
        // Skip samples outside screen bounds - keep marching
        if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {
            continue;
        }
        
        // Sample depth at this screen position and reconstruct view position
        float sampleDepth = texture(gDepth, sampleUV).r;
        vec3 sceneViewPos = viewSpaceFromDepth(sampleUV, sampleDepth);
        
        // Check intersection: ray went behind scene geometry
        float depthDiff = currentViewPos.z - sceneViewPos.z;
        
        if (depthDiff > 0.0 && depthDiff < THICKNESS) {
            // Check if we hit water - skip it to avoid self-reflection
            vec4 hitMetadata = texture(gMetadata, sampleUV);
            bool hitWaterOBJ = hitMetadata.g > 0.9;
            bool hitWaterVoxel = (hitMetadata.r > 0.17 && hitMetadata.r < 0.18);
            if (hitWaterOBJ || hitWaterVoxel) {
                continue;  // Skip water, keep marching
            }
            
            // Hit solid geometry! Sample lit HDR buffer at this location
            hitUV = sampleUV;
            hitColor = texture(hdrBuffer, sampleUV).rgb;
            return true;
        }
    }
    
    return false;
}

void main() {
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dimensions = imageSize(outputImage);
    
    if (coords.x >= dimensions.x || coords.y >= dimensions.y) {
        return;
    }
    
    vec2 uv = (vec2(coords) + 0.5) / vec2(dimensions);
    
    float depth = texture(gDepth, uv).r;
    if (depth >= 0.9999) {
        imageStore(outputImage, coords, vec4(0.0));
        return;
    }
    
    vec4 normalRoughness = texture(gNormal, uv);
    vec3 worldNormal = normalize(normalRoughness.rgb * 2.0 - 1.0);  // Decode from [0,1] to [-1,1]
    vec4 metadata = texture(gMetadata, uv);
    
    // Water detection
    bool isWaterOBJ = metadata.g > 0.9;
    bool isWaterVoxel = (metadata.r > 0.17 && metadata.r < 0.18);
    bool isWater = isWaterOBJ || isWaterVoxel;
    
    // Only apply SSR to water surfaces
    if (!isWater) {
        imageStore(outputImage, coords, vec4(0.0));
        return;
    }
    
    // Reconstruct view position from depth for accurate surface position
    vec3 viewPos = viewSpaceFromDepth(uv, depth);
    vec3 viewNormal = normalize((ssr.viewMatrix * vec4(worldNormal, 0.0)).xyz);
    
    // Calculate reflection in view space
    // Camera is at origin in view space, so incident ray is from camera to surface
    // For reflection, we need to reflect the view direction
    vec3 viewDir = normalize(-viewPos);  // Direction from surface to camera
    vec3 reflectDir = normalize(reflect(-viewDir, viewNormal));  // Reflect incoming ray
    
    // Offset ray origin slightly above surface to avoid self-intersection
    vec3 rayOrigin = viewPos + viewNormal * 0.01;
    
    // Raymarch to find reflection
    vec2 hitUV;
    vec3 hitColor;
    
    if (rayMarch(rayOrigin, reflectDir, hitUV, hitColor)) {
        // Store reflection color with full intensity
        imageStore(outputImage, coords, vec4(hitColor, 1.0));
    } else {
        // No reflection hit - output black (will be handled by composite)
        imageStore(outputImage, coords, vec4(0.0));
    }
}
